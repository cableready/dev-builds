{"version":3,"file":"cable_ready.umd.min.js","sources":["../javascript/enums.js","../javascript/active_element.js","../javascript/utils.js","../javascript/morph_callbacks.js","../javascript/operations.js","../javascript/operation_store.js","../javascript/cable_ready.js","../javascript/cable_consumer.js","../javascript/elements/cable_ready_element.js","../javascript/elements/subscribing_element.js","../javascript/elements/stream_from_element.js","../javascript/elements/updates_for_element.js","../javascript/updatable/inner_updates_compat.js","../javascript/index.js","../javascript/elements/index.js"],"sourcesContent":["export const inputTags = {\n  INPUT: true,\n  TEXTAREA: true,\n  SELECT: true\n}\n\nexport const mutableTags = {\n  INPUT: true,\n  TEXTAREA: true,\n  OPTION: true\n}\n\nexport const textInputTypes = {\n  'datetime-local': true,\n  'select-multiple': true,\n  'select-one': true,\n  color: true,\n  date: true,\n  datetime: true,\n  email: true,\n  month: true,\n  number: true,\n  password: true,\n  range: true,\n  search: true,\n  tel: true,\n  text: true,\n  textarea: true,\n  time: true,\n  url: true,\n  week: true\n}\n","let activeElement\n\nexport default {\n  get element () {\n    return activeElement\n  },\n  set (element) {\n    activeElement = element\n  }\n}\n","import { inputTags, textInputTypes } from './enums'\nimport ActiveElement from './active_element'\n\n// Indicates if the passed element is considered a text input.\n//\nconst isTextInput = element => {\n  return inputTags[element.tagName] && textInputTypes[element.type]\n}\n\n// Assigns focus to the appropriate element... preferring the explicitly passed selector\n//\n// * selector - a CSS selector for the element that should have focus\n//\nconst assignFocus = selector => {\n  const element =\n    selector && selector.nodeType === Node.ELEMENT_NODE\n      ? selector\n      : document.querySelector(selector)\n  const focusElement = element || ActiveElement.element\n  if (focusElement && focusElement.focus) focusElement.focus()\n}\n\n// Dispatches an event on the passed element\n//\n// * element - the element\n// * name - the name of the event\n// * detail - the event detail\n//\nconst dispatch = (element, name, detail = {}) => {\n  const init = { bubbles: true, cancelable: true, detail: detail }\n  const evt = new CustomEvent(name, init)\n  element.dispatchEvent(evt)\n  if (window.jQuery) window.jQuery(element).trigger(name, detail)\n}\n\n// Accepts an xPath query and returns the element found at that position in the DOM\n//\nconst xpathToElement = xpath => {\n  return document.evaluate(\n    xpath,\n    document,\n    null,\n    XPathResult.FIRST_ORDERED_NODE_TYPE,\n    null\n  ).singleNodeValue\n}\n\n// Accepts an xPath query and returns all matching elements in the DOM\n//\nconst xpathToElementArray = xpath => {\n  const result = document.evaluate(\n    xpath,\n    document,\n    null,\n    XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  )\n  const elements = []\n  for (let i = 0; i < result.snapshotLength; i++)\n    elements.push(result.snapshotItem(i))\n  return elements\n}\n\n// Return an array with the class names to be used\n//\n// * names - could be a string or an array of strings for multiple classes.\n//\nconst getClassNames = names => Array(names).flat()\n\n// Perform operation for either the first or all of the elements returned by CSS selector\n//\n// * operation - the instruction payload from perform\n// * callback - the operation function to run for each element\n//\nconst processElements = (operation, callback) => {\n  Array.from(\n    operation.selectAll ? operation.element : [operation.element]\n  ).forEach(callback)\n}\n\n// camelCase to kebab-case\n//\nconst kebabize = str => {\n  return str\n    .split('')\n    .map((letter, idx) => {\n      return letter.toUpperCase() === letter\n        ? `${idx !== 0 ? '-' : ''}${letter.toLowerCase()}`\n        : letter\n    })\n    .join('')\n}\n\n// Provide a standardized pipeline of checks and modifications to all operations based on provided options\n// Currently skips execution if cancelled and implements an optional delay\n//\nconst operate = (operation, callback) => {\n  if (!operation.cancel) {\n    operation.delay ? setTimeout(callback, operation.delay) : callback()\n    return true\n  }\n  return false\n}\n\n// Dispatch life-cycle events with standardized naming\nconst before = (target, operation) =>\n  dispatch(\n    target,\n    `cable-ready:before-${kebabize(operation.operation)}`,\n    operation\n  )\n\nconst after = (target, operation) =>\n  dispatch(\n    target,\n    `cable-ready:after-${kebabize(operation.operation)}`,\n    operation\n  )\n\nfunction debounce (func, timeout) {\n  let timer\n  return (...args) => {\n    clearTimeout(timer)\n    timer = setTimeout(() => func.apply(this, args), timeout)\n  }\n}\n\nfunction handleErrors (response) {\n  if (!response.ok) throw Error(response.statusText)\n  return response\n}\n\n// A proxy method to wrap a fetch call in error handling\n//\n// * url - the URL to fetch\n// * additionalHeaders - an object of additional headers passed to fetch\n//\nasync function graciouslyFetch (url, additionalHeaders) {\n  try {\n    const response = await fetch(url, {\n      headers: {\n        'X-REQUESTED-WITH': 'XmlHttpRequest',\n        ...additionalHeaders\n      }\n    })\n    if (response == undefined) return\n\n    handleErrors(response)\n\n    return response\n  } catch (e) {\n    console.error(`Could not fetch ${url}`)\n  }\n}\n\nexport {\n  isTextInput,\n  assignFocus,\n  dispatch,\n  xpathToElement,\n  xpathToElementArray,\n  getClassNames,\n  processElements,\n  operate,\n  before,\n  after,\n  debounce,\n  handleErrors,\n  graciouslyFetch,\n  kebabize\n}\n","import { mutableTags } from './enums'\nimport { isTextInput } from './utils'\nimport ActiveElement from './active_element'\n\n// Indicates whether or not we should morph an element via onBeforeElUpdated callback\n// SEE: https://github.com/patrick-steele-idem/morphdom#morphdomfromnode-tonode-options--node\n//\nconst shouldMorph = operation => (fromEl, toEl) => {\n  return !shouldMorphCallbacks\n    .map(callback => {\n      return typeof callback === 'function'\n        ? callback(operation, fromEl, toEl)\n        : true\n    })\n    .includes(false)\n}\n\n// Execute any pluggable functions that modify elements after morphing via onElUpdated callback\n//\nconst didMorph = operation => el => {\n  didMorphCallbacks.forEach(callback => {\n    if (typeof callback === 'function') callback(operation, el)\n  })\n}\n\nconst verifyNotMutable = (detail, fromEl, toEl) => {\n  // Skip nodes that are equal:\n  // https://github.com/patrick-steele-idem/morphdom#can-i-make-morphdom-blaze-through-the-dom-tree-even-faster-yes\n  if (!mutableTags[fromEl.tagName] && fromEl.isEqualNode(toEl)) return false\n  return true\n}\n\nconst verifyNotContentEditable = (detail, fromEl, toEl) => {\n  if (fromEl === ActiveElement.element && fromEl.isContentEditable) return false\n  return true\n}\n\nconst verifyNotPermanent = (detail, fromEl, toEl) => {\n  const { permanentAttributeName } = detail\n  if (!permanentAttributeName) return true\n\n  const permanent = fromEl.closest(`[${permanentAttributeName}]`)\n\n  // only morph attributes on the active non-permanent text input\n  if (!permanent && fromEl === ActiveElement.element && isTextInput(fromEl)) {\n    const ignore = { value: true }\n    Array.from(toEl.attributes).forEach(attribute => {\n      if (!ignore[attribute.name])\n        fromEl.setAttribute(attribute.name, attribute.value)\n    })\n    return false\n  }\n\n  return !permanent\n}\n\nconst shouldMorphCallbacks = [\n  verifyNotMutable,\n  verifyNotPermanent,\n  verifyNotContentEditable\n]\nconst didMorphCallbacks = []\n\nexport {\n  shouldMorphCallbacks,\n  didMorphCallbacks,\n  shouldMorph,\n  didMorph,\n  verifyNotMutable,\n  verifyNotContentEditable,\n  verifyNotPermanent\n}\n","import morphdom from 'morphdom'\nimport { shouldMorph, didMorph } from './morph_callbacks'\nimport {\n  assignFocus,\n  dispatch,\n  getClassNames,\n  processElements,\n  before,\n  after,\n  operate\n} from './utils'\n\nexport default {\n  // DOM Mutations\n\n  append: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { html, focusSelector } = operation\n        element.insertAdjacentHTML('beforeend', html || '')\n        assignFocus(focusSelector)\n      })\n      after(element, operation)\n    })\n  },\n\n  graft: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { parent, focusSelector } = operation\n        const parentElement = document.querySelector(parent)\n        if (parentElement) {\n          parentElement.appendChild(element)\n          assignFocus(focusSelector)\n        }\n      })\n      after(element, operation)\n    })\n  },\n\n  innerHtml: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { html, focusSelector } = operation\n        element.innerHTML = html || ''\n        assignFocus(focusSelector)\n      })\n      after(element, operation)\n    })\n  },\n\n  insertAdjacentHtml: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { html, position, focusSelector } = operation\n        element.insertAdjacentHTML(position || 'beforeend', html || '')\n        assignFocus(focusSelector)\n      })\n      after(element, operation)\n    })\n  },\n\n  insertAdjacentText: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { text, position, focusSelector } = operation\n        element.insertAdjacentText(position || 'beforeend', text || '')\n        assignFocus(focusSelector)\n      })\n      after(element, operation)\n    })\n  },\n\n  morph: operation => {\n    processElements(operation, element => {\n      const { html } = operation\n      const template = document.createElement('template')\n      template.innerHTML = String(html).trim()\n      operation.content = template.content\n      const parent = element.parentElement\n      const ordinal = Array.from(parent.children).indexOf(element)\n      before(element, operation)\n      operate(operation, () => {\n        const { childrenOnly, focusSelector } = operation\n        morphdom(\n          element,\n          childrenOnly ? template.content : template.innerHTML,\n          {\n            childrenOnly: !!childrenOnly,\n            onBeforeElUpdated: shouldMorph(operation),\n            onElUpdated: didMorph(operation)\n          }\n        )\n        assignFocus(focusSelector)\n      })\n      after(parent.children[ordinal], operation)\n    })\n  },\n\n  outerHtml: operation => {\n    processElements(operation, element => {\n      const parent = element.parentElement\n      const ordinal = Array.from(parent.children).indexOf(element)\n      before(element, operation)\n      operate(operation, () => {\n        const { html, focusSelector } = operation\n        element.outerHTML = html || ''\n        assignFocus(focusSelector)\n      })\n      after(parent.children[ordinal], operation)\n    })\n  },\n\n  prepend: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { html, focusSelector } = operation\n        element.insertAdjacentHTML('afterbegin', html || '')\n        assignFocus(focusSelector)\n      })\n      after(element, operation)\n    })\n  },\n\n  remove: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { focusSelector } = operation\n        element.remove()\n        assignFocus(focusSelector)\n      })\n      after(document, operation)\n    })\n  },\n\n  replace: operation => {\n    processElements(operation, element => {\n      const parent = element.parentElement\n      const ordinal = Array.from(parent.children).indexOf(element)\n      before(element, operation)\n      operate(operation, () => {\n        const { html, focusSelector } = operation\n        element.outerHTML = html || ''\n        assignFocus(focusSelector)\n      })\n      after(parent.children[ordinal], operation)\n    })\n  },\n\n  textContent: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { text, focusSelector } = operation\n        element.textContent = text != null ? text : ''\n        assignFocus(focusSelector)\n      })\n      after(element, operation)\n    })\n  },\n\n  // Element Property Mutations\n\n  addCssClass: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name } = operation\n        element.classList.add(...getClassNames(name || ''))\n      })\n      after(element, operation)\n    })\n  },\n\n  removeAttribute: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name } = operation\n        element.removeAttribute(name)\n      })\n      after(element, operation)\n    })\n  },\n\n  removeCssClass: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name } = operation\n        element.classList.remove(...getClassNames(name))\n      })\n      after(element, operation)\n    })\n  },\n\n  setAttribute: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name, value } = operation\n        element.setAttribute(name, value || '')\n      })\n      after(element, operation)\n    })\n  },\n\n  setDatasetProperty: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name, value } = operation\n        element.dataset[name] = value || ''\n      })\n      after(element, operation)\n    })\n  },\n\n  setProperty: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name, value } = operation\n        if (name in element) element[name] = value || ''\n      })\n      after(element, operation)\n    })\n  },\n\n  setStyle: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name, value } = operation\n        element.style[name] = value || ''\n      })\n      after(element, operation)\n    })\n  },\n\n  setStyles: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { styles } = operation\n        for (let [name, value] of Object.entries(styles))\n          element.style[name] = value || ''\n      })\n      after(element, operation)\n    })\n  },\n\n  setValue: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { value } = operation\n        element.value = value || ''\n      })\n      after(element, operation)\n    })\n  },\n\n  // DOM Events and Meta-Operations\n\n  dispatchEvent: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name, detail } = operation\n        dispatch(element, name, detail)\n      })\n      after(element, operation)\n    })\n  },\n\n  invokeMethod: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        let firstObjectInChain\n        const { element, receiver, method, args } = operation\n        const chain = method.split('.')\n\n        switch (receiver) {\n          case 'window':\n            firstObjectInChain = window\n            break\n          case 'document':\n            firstObjectInChain = document\n            break\n          default:\n            firstObjectInChain = element\n        }\n        let lastObjectInChain = firstObjectInChain\n        const foundMethod = chain.reduce((lastTerm, nextTerm) => {\n          lastObjectInChain = lastTerm\n          return lastTerm[nextTerm] || {}\n        }, firstObjectInChain)\n\n        if (foundMethod instanceof Function) {\n          foundMethod.apply(lastObjectInChain, args || [])\n        } else {\n          console.warn(\n            `CableReady invoke_method operation failed due to missing '${method}' method for:`,\n            firstObjectInChain\n          )\n        }\n      })\n      after(element, operation)\n    })\n  },\n\n  setMeta: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { name, content } = operation\n      let meta = document.head.querySelector(`meta[name='${name}']`)\n      if (!meta) {\n        meta = document.createElement('meta')\n        meta.name = name\n        document.head.appendChild(meta)\n      }\n      meta.content = content\n    })\n    after(document, operation)\n  },\n\n  // Browser Manipulations\n\n  clearStorage: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { type } = operation\n      const storage = type === 'session' ? sessionStorage : localStorage\n      storage.clear()\n    })\n    after(document, operation)\n  },\n\n  go: operation => {\n    before(window, operation)\n    operate(operation, () => {\n      const { delta } = operation\n      history.go(delta)\n    })\n    after(window, operation)\n  },\n\n  pushState: operation => {\n    before(window, operation)\n    operate(operation, () => {\n      const { state, title, url } = operation\n      history.pushState(state || {}, title || '', url)\n    })\n    after(window, operation)\n  },\n\n  redirectTo: operation => {\n    before(window, operation)\n    operate(operation, () => {\n      let { url, action, turbo } = operation\n      action = action || 'advance'\n      if (typeof turbo === 'undefined') turbo = true\n\n      if (turbo) {\n        if (window.Turbo) window.Turbo.visit(url, { action })\n        if (window.Turbolinks) window.Turbolinks.visit(url, { action })\n        if (!window.Turbo && !window.Turbolinks) window.location.href = url\n      } else {\n        window.location.href = url\n      }\n    })\n    after(window, operation)\n  },\n\n  reload: operation => {\n    before(window, operation)\n    operate(operation, () => {\n      window.location.reload()\n    })\n    after(window, operation)\n  },\n\n  removeStorageItem: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { key, type } = operation\n      const storage = type === 'session' ? sessionStorage : localStorage\n      storage.removeItem(key)\n    })\n    after(document, operation)\n  },\n\n  replaceState: operation => {\n    before(window, operation)\n    operate(operation, () => {\n      const { state, title, url } = operation\n      history.replaceState(state || {}, title || '', url)\n    })\n    after(window, operation)\n  },\n\n  scrollIntoView: operation => {\n    const { element } = operation\n    before(element, operation)\n    operate(operation, () => {\n      element.scrollIntoView(operation)\n    })\n    after(element, operation)\n  },\n\n  setCookie: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { cookie } = operation\n      document.cookie = cookie || ''\n    })\n    after(document, operation)\n  },\n\n  setFocus: operation => {\n    const { element } = operation\n    before(element, operation)\n    operate(operation, () => {\n      assignFocus(element)\n    })\n    after(element, operation)\n  },\n\n  setStorageItem: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { key, value, type } = operation\n      const storage = type === 'session' ? sessionStorage : localStorage\n      storage.setItem(key, value || '')\n    })\n    after(document, operation)\n  },\n\n  // Notifications\n\n  consoleLog: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { message, level } = operation\n      level && ['warn', 'info', 'error'].includes(level)\n        ? console[level](message || '')\n        : console.log(message || '')\n    })\n    after(document, operation)\n  },\n\n  consoleTable: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { data, columns } = operation\n      console.table(data, columns || [])\n    })\n    after(document, operation)\n  },\n\n  notification: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { title, options } = operation\n      Notification.requestPermission().then(result => {\n        operation.permission = result\n        if (result === 'granted') new Notification(title || '', options)\n      })\n    })\n    after(document, operation)\n  }\n}\n","import Operations from './operations'\n\nlet operations = Operations\n\nconst add = newOperations => {\n  operations = { ...operations, ...newOperations }\n}\n\nconst addOperations = operations => {\n  add(operations)\n}\n\nconst addOperation = (name, operation) => {\n  const operations = {}\n  operations[name] = operation\n\n  add(operations)\n}\n\nexport { addOperation, addOperations }\n\nexport default {\n  get all () {\n    return operations\n  }\n}\n","import { xpathToElement, xpathToElementArray, dispatch } from './utils'\n\nimport ActiveElement from './active_element'\nimport OperationStore from './operation_store'\n\nconst perform = (\n  operations,\n  options = { emitMissingElementWarnings: true }\n) => {\n  const batches = {}\n  operations.forEach(operation => {\n    if (!!operation.batch)\n      batches[operation.batch] = batches[operation.batch]\n        ? ++batches[operation.batch]\n        : 1\n  })\n  operations.forEach(operation => {\n    const name = operation.operation\n    try {\n      if (operation.selector) {\n        if (operation.xpath) {\n          operation.element = operation.selectAll\n            ? xpathToElementArray(operation.selector)\n            : xpathToElement(operation.selector)\n        } else {\n          operation.element = operation.selectAll\n            ? document.querySelectorAll(operation.selector)\n            : document.querySelector(operation.selector)\n        }\n      } else {\n        operation.element = document\n      }\n      if (operation.element || options.emitMissingElementWarnings) {\n        ActiveElement.set(document.activeElement)\n        const cableReadyOperation = OperationStore.all[name]\n\n        if (cableReadyOperation) {\n          cableReadyOperation(operation)\n          if (!!operation.batch && --batches[operation.batch] === 0)\n            dispatch(document, 'cable-ready:batch-complete', {\n              batch: operation.batch\n            })\n        } else {\n          console.error(\n            `CableReady couldn't find the \"${name}\" operation. Make sure you use the camelized form when calling an operation method.`\n          )\n        }\n      }\n    } catch (e) {\n      if (operation.element) {\n        console.error(\n          `CableReady detected an error in ${name || 'operation'}: ${\n            e.message\n          }. If you need to support older browsers make sure you've included the corresponding polyfills. https://docs.stimulusreflex.com/setup#polyfills-for-ie11.`\n        )\n        console.error(e)\n      } else {\n        console.warn(\n          `CableReady ${name ||\n            'operation'} failed due to missing DOM element for selector: '${\n            operation.selector\n          }'`\n        )\n      }\n    }\n  })\n}\n\nconst performAsync = (\n  operations,\n  options = { emitMissingElementWarnings: true }\n) => {\n  return new Promise((resolve, reject) => {\n    try {\n      resolve(perform(operations, options))\n    } catch (err) {\n      reject(err)\n    }\n  })\n}\n\nexport { perform, performAsync }\n","let consumer\n\nconst BACKOFF = [25, 50, 75, 100, 200, 250, 500, 800, 1000, 2000]\n\nconst wait = (ms) => new Promise(resolve => setTimeout(resolve, ms))\n\nconst getConsumerWithRetry = async (retry = 0) => {\n  if (consumer) return consumer\n\n  if (retry >= BACKOFF.length) {\n    throw new Error(\"Couldn't obtain a Action Cable consumer within 5s\")\n  }\n\n  await wait(BACKOFF[retry])\n\n  return await getConsumerWithRetry(retry + 1)\n}\n\nexport default {\n  setConsumer (value) {\n    consumer = value\n  },\n\n  get consumer () {\n    return consumer\n  },\n\n  async getConsumer () {\n    return await getConsumerWithRetry()\n  }\n}\n","import { perform } from '../cable_ready'\n\nexport default class CableReadyElement extends HTMLElement {\n  static define () {\n    if (!customElements.get('cable-ready')) {\n      customElements.define('cable-ready', this)\n    }\n  }\n\n  connectedCallback () {\n    setTimeout(() => {\n      try {\n        const operations = JSON.parse(this.scriptElement.textContent)\n        perform(operations)\n      } catch (error) {\n        console.error(error)\n      } finally {\n        try {\n          this.remove()\n        } catch {}\n      }\n    })\n  }\n\n  get scriptElement () {\n    if (\n      this.firstElementChild instanceof HTMLScriptElement &&\n      this.firstElementChild.getAttribute('type') === 'application/json'\n    ) {\n      return this.firstElementChild\n    }\n    throw new Error(\n      'First child element in a `<cable-ready>` tag must be `<script type=\"application/json\">`.'\n    )\n  }\n}\n","export default class SubscribingElement extends HTMLElement {\n  disconnectedCallback () {\n    if (this.channel) this.channel.unsubscribe()\n  }\n\n  createSubscription (consumer, channel, receivedCallback) {\n    this.channel = consumer.subscriptions.create(\n      {\n        channel,\n        identifier: this.identifier\n      },\n      {\n        received: receivedCallback\n      }\n    )\n  }\n\n  get preview () {\n    return (\n      document.documentElement.hasAttribute('data-turbolinks-preview') ||\n      document.documentElement.hasAttribute('data-turbo-preview')\n    )\n  }\n\n  get identifier () {\n    return this.getAttribute('identifier')\n  }\n}\n","import { perform } from '../cable_ready'\nimport SubscribingElement from './subscribing_element'\nimport CableConsumer from '../cable_consumer'\n\nexport default class StreamFromElement extends SubscribingElement {\n  static define () {\n    if (!customElements.get('stream-from')) {\n      customElements.define('stream-from', this)\n    }\n  }\n\n  async connectedCallback () {\n    if (this.preview) return\n\n    const consumer = await CableConsumer.getConsumer()\n\n    if (consumer) {\n      this.createSubscription(\n        consumer,\n        'CableReady::Stream',\n        this.performOperations\n      )\n    } else {\n      console.error(\n        'The `stream_from` helper cannot connect without an ActionCable consumer.\\nPlease run `rails generate cable_ready:helpers` to fix this.'\n      )\n    }\n  }\n\n  performOperations (data) {\n    if (data.cableReady) perform(data.operations)\n  }\n}\n","import morphdom from 'morphdom'\n\nimport SubscribingElement from './subscribing_element'\n\nimport { shouldMorph } from '../morph_callbacks'\nimport { debounce, assignFocus, dispatch, graciouslyFetch } from '../utils'\n\nimport ActiveElement from '../active_element'\nimport CableConsumer from '../cable_consumer'\n\nconst template = `\n<style>\n  :host {\n    display: block;\n  }\n</style>\n<slot></slot>\n`\n\nfunction url (element) {\n  return element.hasAttribute('url')\n    ? element.getAttribute('url')\n    : location.href\n}\n\nexport default class UpdatesForElement extends SubscribingElement {\n  static define () {\n    if (!customElements.get('updates-for')) {\n      customElements.define('updates-for', this)\n    }\n  }\n\n  constructor () {\n    super()\n    const shadowRoot = this.attachShadow({ mode: 'open' })\n    shadowRoot.innerHTML = template\n  }\n\n  async connectedCallback () {\n    if (this.preview) return\n    this.update = debounce(this.update.bind(this), this.debounce)\n\n    const consumer = await CableConsumer.getConsumer()\n\n    if (consumer) {\n      this.createSubscription(consumer, 'CableReady::Stream', this.update)\n    } else {\n      console.error(\n        'The `updates-for` helper cannot connect without an ActionCable consumer.\\nPlease run `rails generate cable_ready:helpers` to fix this.'\n      )\n    }\n  }\n\n  async update (data) {\n    const blocks = Array.from(\n      document.querySelectorAll(this.query),\n      element => new Block(element)\n    )\n\n    // first updates-for element in the DOM *at any given moment* updates all of the others\n    if (blocks[0].element !== this) return\n\n    // hold a reference to the active element so that it can be restored after the morph\n    ActiveElement.set(document.activeElement)\n\n    // store all retrieved HTML in an object keyed by URL to minimize fetch calls\n    this.html = {}\n\n    const uniqueUrls = [...new Set(blocks.map(block => block.url))]\n\n    await Promise.all(\n      uniqueUrls.map(async url => {\n        if (!this.html.hasOwnProperty(url)) {\n          const response = await graciouslyFetch(url, {\n            'X-Cable-Ready': 'update'\n          })\n          this.html[url] = await response.text()\n        }\n      })\n    )\n\n    // track current block index for each URL; referred to as fragments\n    this.index = {}\n\n    blocks.forEach(block => {\n      // if the block's URL is not in the index, initialize it to 0; otherwise, increment it\n      this.index.hasOwnProperty(block.url)\n        ? this.index[block.url]++\n        : (this.index[block.url] = 0)\n\n      block.process(data, this.html, this.index)\n    })\n  }\n\n  get query () {\n    return `updates-for[identifier=\"${this.identifier}\"]`\n  }\n\n  get identifier () {\n    return this.getAttribute('identifier')\n  }\n\n  get debounce () {\n    return this.hasAttribute('debounce')\n      ? parseInt(this.getAttribute('debounce'))\n      : 20\n  }\n}\n\nclass Block {\n  constructor (element) {\n    this.element = element\n  }\n\n  async process (data, html, index) {\n    // with the index incremented, we can now safely bail - before a fetch - if there's no work to be done\n    if (!this.shouldUpdate(data)) return\n\n    const blockIndex = index[this.url]\n    const template = document.createElement('template')\n    this.element.setAttribute('updating', 'updating')\n\n    template.innerHTML = String(html[this.url]).trim()\n\n    await this.resolveTurboFrames(template.content)\n\n    const fragments = template.content.querySelectorAll(this.query)\n\n    if (fragments.length <= blockIndex) {\n      console.warn(\n        `Update aborted due to insufficient number of elements. The offending url is ${this.url}.`\n      )\n      return\n    }\n\n    const operation = {\n      element: this.element,\n      html: fragments[blockIndex],\n      permanentAttributeName: 'data-ignore-updates'\n    }\n\n    dispatch(this.element, 'cable-ready:before-update', operation)\n    morphdom(this.element, fragments[blockIndex], {\n      childrenOnly: true,\n      onBeforeElUpdated: shouldMorph(operation),\n      onElUpdated: _ => {\n        this.element.removeAttribute('updating')\n        dispatch(this.element, 'cable-ready:after-update', operation)\n        assignFocus(operation.focusSelector)\n      }\n    })\n  }\n\n  async resolveTurboFrames (documentFragment) {\n    const reloadingTurboFrames = [\n      ...documentFragment.querySelectorAll(\n        'turbo-frame[src]:not([loading=\"lazy\"])'\n      )\n    ]\n\n    return Promise.all(\n      reloadingTurboFrames.map(frame => {\n        return new Promise(async resolve => {\n          const frameResponse = await graciouslyFetch(\n            frame.getAttribute('src'),\n            {\n              'Turbo-Frame': frame.id,\n              'X-Cable-Ready': 'update'\n            }\n          )\n\n          const frameTemplate = document.createElement('template')\n          frameTemplate.innerHTML = await frameResponse.text()\n\n          // recurse here to get all nested eager loaded frames\n          await this.resolveTurboFrames(frameTemplate.content)\n\n          documentFragment.querySelector(\n            `turbo-frame#${frame.id}`\n          ).innerHTML = String(\n            frameTemplate.content.querySelector(`turbo-frame#${frame.id}`)\n              .innerHTML\n          ).trim()\n\n          resolve()\n        })\n      })\n    )\n  }\n\n  shouldUpdate (data) {\n    // if everything that could prevent an update is false, update this block\n    return !this.ignoresInnerUpdates && this.hasChangesSelectedForUpdate(data)\n  }\n\n  hasChangesSelectedForUpdate (data) {\n    // if there's an only attribute, only update if at least one of the attributes changed is in the allow list\n    const only = this.element.getAttribute('only')\n\n    return !(\n      only &&\n      data.changed &&\n      !only.split(' ').some(attribute => data.changed.includes(attribute))\n    )\n  }\n\n  get ignoresInnerUpdates () {\n    // don't update during a Reflex or Turbolinks redraw\n    return (\n      this.element.hasAttribute('ignore-inner-updates') &&\n      this.element.hasAttribute('performing-inner-update')\n    )\n  }\n\n  get url () {\n    return this.element.hasAttribute('url')\n      ? this.element.getAttribute('url')\n      : location.href\n  }\n\n  get identifier () {\n    return this.element.identifier\n  }\n\n  get query () {\n    return this.element.query\n  }\n}\n","export const registerInnerUpdates = () => {\n  document.addEventListener('stimulus-reflex:before', event => {\n    recursiveMarkUpdatesForElements(event.detail.element)\n  })\n\n  document.addEventListener('stimulus-reflex:after', event => {\n    setTimeout(() => {\n      recursiveUnmarkUpdatesForElements(event.detail.element)\n    })\n  })\n\n  document.addEventListener('turbo:submit-start', event => {\n    recursiveMarkUpdatesForElements(event.target)\n  })\n\n  document.addEventListener('turbo:submit-end', event => {\n    setTimeout(() => {\n      recursiveUnmarkUpdatesForElements(event.target)\n    })\n  })\n}\n\nconst recursiveMarkUpdatesForElements = leaf => {\n  const closestUpdatesFor =\n    leaf && leaf.parentElement && leaf.parentElement.closest('updates-for')\n  if (closestUpdatesFor) {\n    closestUpdatesFor.setAttribute('performing-inner-update', '')\n    recursiveMarkUpdatesForElements(closestUpdatesFor)\n  }\n}\n\nconst recursiveUnmarkUpdatesForElements = leaf => {\n  const closestUpdatesFor =\n    leaf && leaf.parentElement && leaf.parentElement.closest('updates-for')\n  if (closestUpdatesFor) {\n    closestUpdatesFor.removeAttribute('performing-inner-update')\n    recursiveUnmarkUpdatesForElements(closestUpdatesFor)\n  }\n}\n","import packageInfo from '../package.json'\nimport { perform, performAsync } from './cable_ready'\nimport { initialize } from './elements'\nimport { shouldMorphCallbacks, didMorphCallbacks } from './morph_callbacks'\n\nimport * as MorphCallbacks from './morph_callbacks'\nimport * as Utils from './utils'\n\nimport OperationStore, { addOperation, addOperations } from './operation_store'\nimport CableReadyElement from './elements/cable_ready_element'\nimport StreamFromElement from './elements/stream_from_element'\nimport UpdatesForElement from './elements/updates_for_element'\nimport SubscribingElement from './elements/subscribing_element'\nimport CableConsumer from './cable_consumer'\n\nexport {\n  Utils,\n  MorphCallbacks,\n  CableReadyElement,\n  StreamFromElement,\n  UpdatesForElement,\n  SubscribingElement\n}\n\nconst global = {\n  perform,\n  performAsync,\n  shouldMorphCallbacks,\n  didMorphCallbacks,\n  initialize,\n  addOperation,\n  addOperations,\n  version: packageInfo.version,\n  cable: CableConsumer,\n  get DOMOperations () {\n    console.warn(\n      'DEPRECATED: Please use `CableReady.operations` instead of `CableReady.DOMOperations`'\n    )\n    return OperationStore.all\n  },\n  get operations () {\n    return OperationStore.all\n  },\n  get consumer () {\n    return CableConsumer.consumer\n  }\n}\n\nwindow.CableReady = global\n\nexport default global\n","import CableConsumer from '../cable_consumer'\n\nimport CableReadyElement from './cable_ready_element'\nimport StreamFromElement from './stream_from_element'\nimport UpdatesForElement from './updates_for_element'\n\nimport { registerInnerUpdates } from '../updatable/inner_updates_compat'\n\nconst initialize = (initializeOptions = {}) => {\n  const { consumer } = initializeOptions\n\n  registerInnerUpdates()\n\n  if (consumer) {\n    CableConsumer.setConsumer(consumer)\n  } else {\n    console.error(\n      'CableReady requires a reference to your Action Cable `consumer` for its helpers to function.\\nEnsure that you have imported the `CableReady` package as well as `consumer` from your `channels` folder, then call `CableReady.initialize({ consumer })`.'\n    )\n  }\n\n  CableReadyElement.define()\n  StreamFromElement.define()\n  UpdatesForElement.define()\n}\n\nexport { initialize }\n"],"names":["inputTags","INPUT","TEXTAREA","SELECT","mutableTags","OPTION","textInputTypes","color","date","datetime","email","month","number","password","range","search","tel","text","textarea","time","url","week","activeElement","ActiveElement","element","set","isTextInput","tagName","type","assignFocus","selector","focusElement","nodeType","Node","ELEMENT_NODE","document","querySelector","focus","dispatch","name","detail","evt","CustomEvent","bubbles","cancelable","dispatchEvent","window","jQuery","trigger","xpathToElement","xpath","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","xpathToElementArray","result","ORDERED_NODE_SNAPSHOT_TYPE","elements","i","snapshotLength","push","snapshotItem","getClassNames","names","Array","flat","processElements","operation","callback","from","selectAll","forEach","kebabize","str","split","map","letter","idx","toUpperCase","toLowerCase","join","operate","cancel","delay","setTimeout","before","target","after","debounce","func","timeout","timer","args","clearTimeout","apply","this","handleErrors","response","ok","Error","statusText","async","graciouslyFetch","additionalHeaders","fetch","headers","undefined","e","console","error","shouldMorph","fromEl","toEl","shouldMorphCallbacks","includes","didMorph","el","didMorphCallbacks","verifyNotMutable","isEqualNode","verifyNotContentEditable","isContentEditable","verifyNotPermanent","permanentAttributeName","permanent","closest","ignore","value","attributes","attribute","setAttribute","Operations","append","html","focusSelector","insertAdjacentHTML","graft","parent","parentElement","appendChild","innerHtml","innerHTML","insertAdjacentHtml","position","insertAdjacentText","morph","template","createElement","String","trim","content","ordinal","children","indexOf","childrenOnly","morphdom","onBeforeElUpdated","onElUpdated","outerHtml","outerHTML","prepend","remove","replace","textContent","addCssClass","classList","add","removeAttribute","removeCssClass","setDatasetProperty","dataset","setProperty","setStyle","style","setStyles","styles","Object","entries","setValue","invokeMethod","firstObjectInChain","receiver","method","chain","lastObjectInChain","foundMethod","reduce","lastTerm","nextTerm","Function","warn","setMeta","meta","head","clearStorage","sessionStorage","localStorage","clear","go","delta","history","pushState","state","title","redirectTo","action","turbo","Turbo","visit","Turbolinks","location","href","reload","removeStorageItem","key","removeItem","replaceState","scrollIntoView","setCookie","cookie","setFocus","setStorageItem","setItem","consoleLog","message","level","log","consoleTable","data","columns","table","notification","options","Notification","requestPermission","then","permission","operations","newOperations","OperationStore","all","perform","emitMissingElementWarnings","batches","batch","querySelectorAll","cableReadyOperation","consumer","BACKOFF","getConsumerWithRetry","retry","length","ms","Promise","resolve","CableConsumer","setConsumer","CableReadyElement","HTMLElement","static","customElements","get","define","connectedCallback","JSON","parse","scriptElement","firstElementChild","HTMLScriptElement","getAttribute","SubscribingElement","disconnectedCallback","channel","unsubscribe","createSubscription","receivedCallback","subscriptions","create","identifier","received","preview","documentElement","hasAttribute","StreamFromElement","getConsumer","performOperations","cableReady","UpdatesForElement","constructor","super","attachShadow","mode","update","bind","blocks","query","Block","uniqueUrls","Set","block","hasOwnProperty","index","process","parseInt","shouldUpdate","blockIndex","resolveTurboFrames","fragments","_","documentFragment","reloadingTurboFrames","frame","frameResponse","id","frameTemplate","ignoresInnerUpdates","hasChangesSelectedForUpdate","only","changed","some","recursiveMarkUpdatesForElements","leaf","closestUpdatesFor","recursiveUnmarkUpdatesForElements","global","performAsync","reject","err","initialize","initializeOptions","addEventListener","event","addOperation","addOperations","version","packageInfo","cable","DOMOperations","CableReady"],"mappings":"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"}