{"version":3,"file":"cable_ready.module.js","sources":["../javascript/enums.js","../javascript/active_element.js","../javascript/utils.js","../javascript/morph_callbacks.js","../javascript/operations.js","../javascript/operation_store.js","../javascript/cable_ready.js","../javascript/cable_consumer.js","../javascript/elements/subscribing_element.js","../javascript/elements/stream_from_element.js","../javascript/elements/updates_for_element.js","../javascript/updatable/inner_updates_compat.js","../javascript/elements/index.js","../javascript/index.js"],"sourcesContent":["export const inputTags = {\n  INPUT: true,\n  TEXTAREA: true,\n  SELECT: true\n}\n\nexport const mutableTags = {\n  INPUT: true,\n  TEXTAREA: true,\n  OPTION: true\n}\n\nexport const textInputTypes = {\n  'datetime-local': true,\n  'select-multiple': true,\n  'select-one': true,\n  color: true,\n  date: true,\n  datetime: true,\n  email: true,\n  month: true,\n  number: true,\n  password: true,\n  range: true,\n  search: true,\n  tel: true,\n  text: true,\n  textarea: true,\n  time: true,\n  url: true,\n  week: true\n}\n","let activeElement\n\nexport default {\n  get element () {\n    return activeElement\n  },\n  set (element) {\n    activeElement = element\n  }\n}\n","import { inputTags, textInputTypes } from './enums'\nimport ActiveElement from './active_element'\n\n// Indicates if the passed element is considered a text input.\n//\nconst isTextInput = element => {\n  return inputTags[element.tagName] && textInputTypes[element.type]\n}\n\n// Assigns focus to the appropriate element... preferring the explicitly passed selector\n//\n// * selector - a CSS selector for the element that should have focus\n//\nconst assignFocus = selector => {\n  const element =\n    selector && selector.nodeType === Node.ELEMENT_NODE\n      ? selector\n      : document.querySelector(selector)\n  const focusElement = element || ActiveElement.element\n  if (focusElement && focusElement.focus) focusElement.focus()\n}\n\n// Dispatches an event on the passed element\n//\n// * element - the element\n// * name - the name of the event\n// * detail - the event detail\n//\nconst dispatch = (element, name, detail = {}) => {\n  const init = { bubbles: true, cancelable: true, detail: detail }\n  const evt = new CustomEvent(name, init)\n  element.dispatchEvent(evt)\n  if (window.jQuery) window.jQuery(element).trigger(name, detail)\n}\n\n// Accepts an xPath query and returns the element found at that position in the DOM\n//\nconst xpathToElement = xpath => {\n  return document.evaluate(\n    xpath,\n    document,\n    null,\n    XPathResult.FIRST_ORDERED_NODE_TYPE,\n    null\n  ).singleNodeValue\n}\n\n// Return an array with the class names to be used\n//\n// * names - could be a string or an array of strings for multiple classes.\n//\nconst getClassNames = names => Array(names).flat()\n\n// Perform operation for either the first or all of the elements returned by CSS selector\n//\n// * operation - the instruction payload from perform\n// * callback - the operation function to run for each element\n//\nconst processElements = (operation, callback) => {\n  Array.from(\n    operation.selectAll ? operation.element : [operation.element]\n  ).forEach(callback)\n}\n\n// camelCase to kebab-case\n//\nconst kebabize = str => {\n  return str\n    .split('')\n    .map((letter, idx) => {\n      return letter.toUpperCase() === letter\n        ? `${idx !== 0 ? '-' : ''}${letter.toLowerCase()}`\n        : letter\n    })\n    .join('')\n}\n\n// Provide a standardized pipeline of checks and modifications to all operations based on provided options\n// Currently skips execution if cancelled and implements an optional delay\n//\nconst operate = (operation, callback) => {\n  if (!operation.cancel) {\n    operation.delay ? setTimeout(callback, operation.delay) : callback()\n    return true\n  }\n  return false\n}\n\n// Dispatch life-cycle events with standardized naming\nconst before = (target, operation) =>\n  dispatch(\n    target,\n    `cable-ready:before-${kebabize(operation.operation)}`,\n    operation\n  )\n\nconst after = (target, operation) =>\n  dispatch(\n    target,\n    `cable-ready:after-${kebabize(operation.operation)}`,\n    operation\n  )\n\nfunction debounce (func, timeout) {\n  let timer\n  return (...args) => {\n    clearTimeout(timer)\n    timer = setTimeout(() => func.apply(this, args), timeout)\n  }\n}\n\nfunction handleErrors (response) {\n  if (!response.ok) throw Error(response.statusText)\n  return response\n}\n\n// A proxy method to wrap a fetch call in error handling\n//\n// * url - the URL to fetch\n// * additionalHeaders - an object of additional headers passed to fetch\n//\nasync function graciouslyFetch (url, additionalHeaders) {\n  try {\n    const response = await fetch(url, {\n      headers: {\n        'X-REQUESTED-WITH': 'XmlHttpRequest',\n        ...additionalHeaders\n      }\n    })\n    if (response == undefined) return\n\n    handleErrors(response)\n\n    return response\n  } catch (e) {\n    console.error(`Could not fetch ${url}`)\n  }\n}\n\nexport {\n  isTextInput,\n  assignFocus,\n  dispatch,\n  xpathToElement,\n  getClassNames,\n  processElements,\n  operate,\n  before,\n  after,\n  debounce,\n  handleErrors,\n  graciouslyFetch,\n  kebabize\n}\n","import { mutableTags } from './enums'\nimport { isTextInput } from './utils'\nimport ActiveElement from './active_element'\n\n// Indicates whether or not we should morph an element via onBeforeElUpdated callback\n// SEE: https://github.com/patrick-steele-idem/morphdom#morphdomfromnode-tonode-options--node\n//\nconst shouldMorph = operation => (fromEl, toEl) => {\n  return !shouldMorphCallbacks\n    .map(callback => {\n      return typeof callback === 'function'\n        ? callback(operation, fromEl, toEl)\n        : true\n    })\n    .includes(false)\n}\n\n// Execute any pluggable functions that modify elements after morphing via onElUpdated callback\n//\nconst didMorph = operation => el => {\n  didMorphCallbacks.forEach(callback => {\n    if (typeof callback === 'function') callback(operation, el)\n  })\n}\n\nconst verifyNotMutable = (detail, fromEl, toEl) => {\n  // Skip nodes that are equal:\n  // https://github.com/patrick-steele-idem/morphdom#can-i-make-morphdom-blaze-through-the-dom-tree-even-faster-yes\n  if (!mutableTags[fromEl.tagName] && fromEl.isEqualNode(toEl)) return false\n  return true\n}\n\nconst verifyNotContentEditable = (detail, fromEl, toEl) => {\n  if (fromEl === ActiveElement.element && fromEl.isContentEditable) return false\n  return true\n}\n\nconst verifyNotPermanent = (detail, fromEl, toEl) => {\n  const { permanentAttributeName } = detail\n  if (!permanentAttributeName) return true\n\n  const permanent = fromEl.closest(`[${permanentAttributeName}]`)\n\n  // only morph attributes on the active non-permanent text input\n  if (!permanent && fromEl === ActiveElement.element && isTextInput(fromEl)) {\n    const ignore = { value: true }\n    Array.from(toEl.attributes).forEach(attribute => {\n      if (!ignore[attribute.name])\n        fromEl.setAttribute(attribute.name, attribute.value)\n    })\n    return false\n  }\n\n  return !permanent\n}\n\nconst shouldMorphCallbacks = [\n  verifyNotMutable,\n  verifyNotPermanent,\n  verifyNotContentEditable\n]\nconst didMorphCallbacks = []\n\nexport {\n  shouldMorphCallbacks,\n  didMorphCallbacks,\n  shouldMorph,\n  didMorph,\n  verifyNotMutable,\n  verifyNotContentEditable,\n  verifyNotPermanent\n}\n","import morphdom from 'morphdom'\nimport { shouldMorph, didMorph } from './morph_callbacks'\nimport {\n  assignFocus,\n  dispatch,\n  getClassNames,\n  processElements,\n  before,\n  after,\n  operate\n} from './utils'\n\nexport default {\n  // DOM Mutations\n\n  append: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { html, focusSelector } = operation\n        element.insertAdjacentHTML('beforeend', html || '')\n        assignFocus(focusSelector)\n      })\n      after(element, operation)\n    })\n  },\n\n  graft: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { parent, focusSelector } = operation\n        const parentElement = document.querySelector(parent)\n        if (parentElement) {\n          parentElement.appendChild(element)\n          assignFocus(focusSelector)\n        }\n      })\n      after(element, operation)\n    })\n  },\n\n  innerHtml: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { html, focusSelector } = operation\n        element.innerHTML = html || ''\n        assignFocus(focusSelector)\n      })\n      after(element, operation)\n    })\n  },\n\n  insertAdjacentHtml: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { html, position, focusSelector } = operation\n        element.insertAdjacentHTML(position || 'beforeend', html || '')\n        assignFocus(focusSelector)\n      })\n      after(element, operation)\n    })\n  },\n\n  insertAdjacentText: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { text, position, focusSelector } = operation\n        element.insertAdjacentText(position || 'beforeend', text || '')\n        assignFocus(focusSelector)\n      })\n      after(element, operation)\n    })\n  },\n\n  morph: operation => {\n    processElements(operation, element => {\n      const { html } = operation\n      const template = document.createElement('template')\n      template.innerHTML = String(html).trim()\n      operation.content = template.content\n      const parent = element.parentElement\n      const ordinal = Array.from(parent.children).indexOf(element)\n      before(element, operation)\n      operate(operation, () => {\n        const { childrenOnly, focusSelector } = operation\n        morphdom(\n          element,\n          childrenOnly ? template.content : template.innerHTML,\n          {\n            childrenOnly: !!childrenOnly,\n            onBeforeElUpdated: shouldMorph(operation),\n            onElUpdated: didMorph(operation)\n          }\n        )\n        assignFocus(focusSelector)\n      })\n      after(parent.children[ordinal], operation)\n    })\n  },\n\n  outerHtml: operation => {\n    processElements(operation, element => {\n      const parent = element.parentElement\n      const ordinal = Array.from(parent.children).indexOf(element)\n      before(element, operation)\n      operate(operation, () => {\n        const { html, focusSelector } = operation\n        element.outerHTML = html || ''\n        assignFocus(focusSelector)\n      })\n      after(parent.children[ordinal], operation)\n    })\n  },\n\n  prepend: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { html, focusSelector } = operation\n        element.insertAdjacentHTML('afterbegin', html || '')\n        assignFocus(focusSelector)\n      })\n      after(element, operation)\n    })\n  },\n\n  remove: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { focusSelector } = operation\n        element.remove()\n        assignFocus(focusSelector)\n      })\n      after(document, operation)\n    })\n  },\n\n  replace: operation => {\n    processElements(operation, element => {\n      const parent = element.parentElement\n      const ordinal = Array.from(parent.children).indexOf(element)\n      before(element, operation)\n      operate(operation, () => {\n        const { html, focusSelector } = operation\n        element.outerHTML = html || ''\n        assignFocus(focusSelector)\n      })\n      after(parent.children[ordinal], operation)\n    })\n  },\n\n  textContent: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { text, focusSelector } = operation\n        element.textContent = (text != null) ? text : ''\n        assignFocus(focusSelector)\n      })\n      after(element, operation)\n    })\n  },\n\n  // Element Property Mutations\n\n  addCssClass: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name } = operation\n        element.classList.add(...getClassNames(name || ''))\n      })\n      after(element, operation)\n    })\n  },\n\n  removeAttribute: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name } = operation\n        element.removeAttribute(name)\n      })\n      after(element, operation)\n    })\n  },\n\n  removeCssClass: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name } = operation\n        element.classList.remove(...getClassNames(name))\n      })\n      after(element, operation)\n    })\n  },\n\n  setAttribute: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name, value } = operation\n        element.setAttribute(name, value || '')\n      })\n      after(element, operation)\n    })\n  },\n\n  setDatasetProperty: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name, value } = operation\n        element.dataset[name] = value || ''\n      })\n      after(element, operation)\n    })\n  },\n\n  setProperty: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name, value } = operation\n        if (name in element) element[name] = value || ''\n      })\n      after(element, operation)\n    })\n  },\n\n  setStyle: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name, value } = operation\n        element.style[name] = value || ''\n      })\n      after(element, operation)\n    })\n  },\n\n  setStyles: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { styles } = operation\n        for (let [name, value] of Object.entries(styles))\n          element.style[name] = value || ''\n      })\n      after(element, operation)\n    })\n  },\n\n  setValue: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { value } = operation\n        element.value = value || ''\n      })\n      after(element, operation)\n    })\n  },\n\n  // DOM Events\n\n  dispatchEvent: operation => {\n    processElements(operation, element => {\n      before(element, operation)\n      operate(operation, () => {\n        const { name, detail } = operation\n        dispatch(element, name, detail)\n      })\n      after(element, operation)\n    })\n  },\n\n  setMeta: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { name, content } = operation\n      let meta = document.head.querySelector(`meta[name='${name}']`)\n      if (!meta) {\n        meta = document.createElement('meta')\n        meta.name = name\n        document.head.appendChild(meta)\n      }\n      meta.content = content\n    })\n    after(document, operation)\n  },\n\n  // Browser Manipulations\n\n  clearStorage: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { type } = operation\n      const storage = type === 'session' ? sessionStorage : localStorage\n      storage.clear()\n    })\n    after(document, operation)\n  },\n\n  go: operation => {\n    before(window, operation)\n    operate(operation, () => {\n      const { delta } = operation\n      history.go(delta)\n    })\n    after(window, operation)\n  },\n\n  pushState: operation => {\n    before(window, operation)\n    operate(operation, () => {\n      const { state, title, url } = operation\n      history.pushState(state || {}, title || '', url)\n    })\n    after(window, operation)\n  },\n\n  redirectTo: operation => {\n    before(window, operation)\n    operate(operation, () => {\n      let { url, action } = operation\n      action = action || 'advance'\n      if (window.Turbo) window.Turbo.visit(url, { action })\n      if (window.Turbolinks) window.Turbolinks.visit(url, { action })\n      if (!window.Turbo && !window.Turbolinks) window.location.href = url\n    })\n    after(window, operation)\n  },\n\n  reload: operation => {\n    before(window, operation)\n    operate(operation, () => {\n      window.location.reload()\n    })\n    after(window, operation)\n  },\n\n  removeStorageItem: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { key, type } = operation\n      const storage = type === 'session' ? sessionStorage : localStorage\n      storage.removeItem(key)\n    })\n    after(document, operation)\n  },\n\n  replaceState: operation => {\n    before(window, operation)\n    operate(operation, () => {\n      const { state, title, url } = operation\n      history.replaceState(state || {}, title || '', url)\n    })\n    after(window, operation)\n  },\n\n  scrollIntoView: operation => {\n    const { element } = operation\n    before(element, operation)\n    operate(operation, () => {\n      element.scrollIntoView(operation)\n    })\n    after(element, operation)\n  },\n\n  setCookie: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { cookie } = operation\n      document.cookie = cookie || ''\n    })\n    after(document, operation)\n  },\n\n  setFocus: operation => {\n    const { element } = operation\n    before(element, operation)\n    operate(operation, () => {\n      assignFocus(element)\n    })\n    after(element, operation)\n  },\n\n  setStorageItem: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { key, value, type } = operation\n      const storage = type === 'session' ? sessionStorage : localStorage\n      storage.setItem(key, value || '')\n    })\n    after(document, operation)\n  },\n\n  // Notifications\n\n  consoleLog: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { message, level } = operation\n      level && ['warn', 'info', 'error'].includes(level)\n        ? console[level](message || '')\n        : console.log(message || '')\n    })\n    after(document, operation)\n  },\n\n  consoleTable: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { data, columns } = operation\n      console.table(data, columns || [])\n    })\n    after(document, operation)\n  },\n\n  notification: operation => {\n    before(document, operation)\n    operate(operation, () => {\n      const { title, options } = operation\n      Notification.requestPermission().then(result => {\n        operation.permission = result\n        if (result === 'granted') new Notification(title || '', options)\n      })\n    })\n    after(document, operation)\n  }\n}\n","import Operations from './operations'\n\nlet operations = Operations\n\nconst add = newOperations => {\n  operations = { ...operations, ...newOperations }\n}\n\nconst addOperations = operations => {\n  add(operations)\n}\n\nconst addOperation = (name, operation) => {\n  const operations = {}\n  operations[name] = operation\n\n  add(operations)\n}\n\nexport { addOperation, addOperations }\n\nexport default {\n  get all () {\n    return operations\n  }\n}\n","import { xpathToElement, dispatch } from './utils'\n\nimport ActiveElement from './active_element'\nimport OperationStore from './operation_store'\n\nconst perform = (\n  operations,\n  options = { emitMissingElementWarnings: true }\n) => {\n  const batches = {}\n  operations.forEach(operation => {\n    if (!!operation.batch)\n      batches[operation.batch] = batches[operation.batch]\n        ? ++batches[operation.batch]\n        : 1\n  })\n  operations.forEach(operation => {\n    const name = operation.operation\n    try {\n      if (operation.selector) {\n        operation.element = operation.xpath\n          ? xpathToElement(operation.selector)\n          : document[\n              operation.selectAll ? 'querySelectorAll' : 'querySelector'\n            ](operation.selector)\n      } else {\n        operation.element = document\n      }\n      if (operation.element || options.emitMissingElementWarnings) {\n        ActiveElement.set(document.activeElement)\n        const cableReadyOperation = OperationStore.all[name]\n\n        if (cableReadyOperation) {\n          cableReadyOperation(operation)\n          if (!!operation.batch && --batches[operation.batch] === 0)\n            dispatch(document, 'cable-ready:batch-complete', {\n              batch: operation.batch\n            })\n        } else {\n          console.error(\n            `CableReady couldn't find the \"${name}\" operation. Make sure you use the camelized form when calling an operation method.`\n          )\n        }\n      }\n    } catch (e) {\n      if (operation.element) {\n        console.error(\n          `CableReady detected an error in ${name || 'operation'}: ${\n            e.message\n          }. If you need to support older browsers make sure you've included the corresponding polyfills. https://docs.stimulusreflex.com/setup#polyfills-for-ie11.`\n        )\n        console.error(e)\n      } else {\n        console.warn(\n          `CableReady ${name ||\n            'operation'} failed due to missing DOM element for selector: '${\n            operation.selector\n          }'`\n        )\n      }\n    }\n  })\n}\n\nconst performAsync = (\n  operations,\n  options = { emitMissingElementWarnings: true }\n) => {\n  return new Promise((resolve, reject) => {\n    try {\n      resolve(perform(operations, options))\n    } catch (err) {\n      reject(err)\n    }\n  })\n}\n\nexport { perform, performAsync }\n","let consumer\n\nconst BACKOFF = [25, 50, 75, 100, 200, 250, 500, 800, 1000, 2000]\n\nconst wait = (ms) => new Promise(resolve => setTimeout(resolve, ms))\n\nconst getConsumerWithRetry = async (retry = 0) => {\n  if (consumer) return consumer\n\n  if (retry >= BACKOFF.length) {\n    throw new Error(\"Couldn't obtain a Action Cable consumer within 5s\")\n  }\n\n  await wait(BACKOFF[retry])\n\n  return await getConsumerWithRetry(retry + 1)\n}\n\nexport default {\n  setConsumer (value) {\n    consumer = value\n  },\n\n  get consumer () {\n    return consumer\n  },\n\n  async getConsumer () {\n    return await getConsumerWithRetry()\n  }\n}\n","export default class SubscribingElement extends HTMLElement {\n  disconnectedCallback () {\n    if (this.channel) this.channel.unsubscribe()\n  }\n\n  createSubscription (consumer, channel, receivedCallback) {\n    this.channel = consumer.subscriptions.create(\n      {\n        channel,\n        identifier: this.identifier\n      },\n      {\n        received: receivedCallback\n      }\n    )\n  }\n\n  get preview () {\n    return (\n      document.documentElement.hasAttribute('data-turbolinks-preview') ||\n      document.documentElement.hasAttribute('data-turbo-preview')\n    )\n  }\n\n  get identifier () {\n    return this.getAttribute('identifier')\n  }\n}\n","import { perform } from '../cable_ready'\nimport SubscribingElement from './subscribing_element'\nimport CableConsumer from '../cable_consumer'\n\nexport default class StreamFromElement extends SubscribingElement {\n  async connectedCallback () {\n    if (this.preview) return\n\n    const consumer = await CableConsumer.getConsumer()\n\n    if (consumer) {\n      this.createSubscription(\n        consumer,\n        'CableReady::Stream',\n        this.performOperations\n      )\n    } else {\n      console.error(\n        'The `stream_from` helper cannot connect without an ActionCable consumer.\\nPlease run `rails generate cable_ready:helpers` to fix this.'\n      )\n    }\n  }\n\n  performOperations (data) {\n    if (data.cableReady) perform(data.operations)\n  }\n}\n","import morphdom from 'morphdom'\n\nimport SubscribingElement from './subscribing_element'\n\nimport { shouldMorph } from '../morph_callbacks'\nimport { debounce, assignFocus, dispatch, graciouslyFetch } from '../utils'\n\nimport ActiveElement from '../active_element'\nimport CableConsumer from '../cable_consumer'\n\nconst template = `\n<style>\n  :host {\n    display: block;\n  }\n</style>\n<slot></slot>\n`\n\nfunction url (element) {\n  return element.hasAttribute('url')\n    ? element.getAttribute('url')\n    : location.href\n}\n\nexport default class UpdatesForElement extends SubscribingElement {\n  constructor () {\n    super()\n    const shadowRoot = this.attachShadow({ mode: 'open' })\n    shadowRoot.innerHTML = template\n  }\n\n  async connectedCallback () {\n    if (this.preview) return\n    this.update = debounce(this.update.bind(this), this.debounce)\n\n    const consumer = await CableConsumer.getConsumer()\n\n    if (consumer) {\n      this.createSubscription(consumer, 'CableReady::Stream', this.update)\n    } else {\n      console.error(\n        'The `updates-for` helper cannot connect without an ActionCable consumer.\\nPlease run `rails generate cable_ready:helpers` to fix this.'\n      )\n    }\n  }\n\n  async update (data) {\n    const blocks = Array.from(\n      document.querySelectorAll(this.query),\n      element => new Block(element)\n    )\n\n    // first updates-for element in the DOM *at any given moment* updates all of the others\n    if (blocks[0].element !== this) return\n\n    // hold a reference to the active element so that it can be restored after the morph\n    ActiveElement.set(document.activeElement)\n\n    // store all retrieved HTML in an object keyed by URL to minimize fetch calls\n    this.html = {}\n\n    const uniqueUrls = [...new Set(blocks.map(block => block.url))]\n\n    await Promise.all(\n      uniqueUrls.map(async url => {\n        if (!this.html.hasOwnProperty(url)) {\n          const response = await graciouslyFetch(url, {\n            'X-Cable-Ready': 'update'\n          })\n          this.html[url] = await response.text()\n        }\n      })\n    )\n\n    // track current block index for each URL; referred to as fragments\n    this.index = {}\n\n    blocks.forEach(block => {\n      // if the block's URL is not in the index, initialize it to 0; otherwise, increment it\n      this.index.hasOwnProperty(block.url)\n        ? this.index[block.url]++\n        : (this.index[block.url] = 0)\n\n      block.process(data, this.html, this.index)\n    })\n  }\n\n  get query () {\n    return `updates-for[identifier=\"${this.identifier}\"]`\n  }\n\n  get identifier () {\n    return this.getAttribute('identifier')\n  }\n\n  get debounce () {\n    return this.hasAttribute('debounce')\n      ? parseInt(this.getAttribute('debounce'))\n      : 20\n  }\n}\n\nclass Block {\n  constructor (element) {\n    this.element = element\n  }\n\n  async process (data, html, index) {\n    // with the index incremented, we can now safely bail - before a fetch - if there's no work to be done\n    if (!this.shouldUpdate(data)) return\n\n    const blockIndex = index[this.url]\n    const template = document.createElement('template')\n    this.element.setAttribute('updating', 'updating')\n\n    template.innerHTML = String(html[this.url]).trim()\n\n    await this.resolveTurboFrames(template.content)\n\n    const fragments = template.content.querySelectorAll(this.query)\n\n    if (fragments.length <= blockIndex) {\n      console.warn(\n        `Update aborted due to insufficient number of elements. The offending url is ${this.url}.`\n      )\n      return\n    }\n\n    const operation = {\n      element: this.element,\n      html: fragments[blockIndex],\n      permanentAttributeName: 'data-ignore-updates'\n    }\n\n    dispatch(this.element, 'cable-ready:before-update', operation)\n    morphdom(this.element, fragments[blockIndex], {\n      childrenOnly: true,\n      onBeforeElUpdated: shouldMorph(operation),\n      onElUpdated: _ => {\n        this.element.removeAttribute('updating')\n        dispatch(this.element, 'cable-ready:after-update', operation)\n        assignFocus(operation.focusSelector)\n      }\n    })\n  }\n\n  async resolveTurboFrames (documentFragment) {\n    const reloadingTurboFrames = [\n      ...documentFragment.querySelectorAll(\n        'turbo-frame[src]:not([loading=\"lazy\"])'\n      )\n    ]\n\n    return Promise.all(\n      reloadingTurboFrames.map(frame => {\n        return new Promise(async resolve => {\n          const frameResponse = await graciouslyFetch(\n            frame.getAttribute('src'),\n            {\n              'Turbo-Frame': frame.id,\n              'X-Cable-Ready': 'update'\n            }\n          )\n\n          const frameTemplate = document.createElement('template')\n          frameTemplate.innerHTML = await frameResponse.text()\n\n          // recurse here to get all nested eager loaded frames\n          await this.resolveTurboFrames(frameTemplate.content)\n\n          documentFragment.querySelector(\n            `turbo-frame#${frame.id}`\n          ).innerHTML = String(\n            frameTemplate.content.querySelector(`turbo-frame#${frame.id}`)\n              .innerHTML\n          ).trim()\n\n          resolve()\n        })\n      })\n    )\n  }\n\n  shouldUpdate (data) {\n    // if everything that could prevent an update is false, update this block\n    return !this.ignoresInnerUpdates && this.hasChangesSelectedForUpdate(data)\n  }\n\n  hasChangesSelectedForUpdate (data) {\n    // if there's an only attribute, only update if at least one of the attributes changed is in the allow list\n    const only = this.element.getAttribute('only')\n\n    return !(\n      only &&\n      data.changed &&\n      !only.split(' ').some(attribute => data.changed.includes(attribute))\n    )\n  }\n\n  get ignoresInnerUpdates () {\n    // don't update during a Reflex or Turbolinks redraw\n    return (\n      this.element.hasAttribute('ignore-inner-updates') &&\n      this.element.hasAttribute('performing-inner-update')\n    )\n  }\n\n  get url () {\n    return this.element.hasAttribute('url')\n      ? this.element.getAttribute('url')\n      : location.href\n  }\n\n  get identifier () {\n    return this.element.identifier\n  }\n\n  get query () {\n    return this.element.query\n  }\n}\n","export const registerInnerUpdates = () => {\n  document.addEventListener('stimulus-reflex:before', event => {\n    recursiveMarkUpdatesForElements(event.detail.element)\n  })\n\n  document.addEventListener('stimulus-reflex:after', event => {\n    setTimeout(() => {\n      recursiveUnmarkUpdatesForElements(event.detail.element)\n    })\n  })\n\n  document.addEventListener('turbo:submit-start', event => {\n    recursiveMarkUpdatesForElements(event.target)\n  })\n\n  document.addEventListener('turbo:submit-end', event => {\n    setTimeout(() => {\n      recursiveUnmarkUpdatesForElements(event.target)\n    })\n  })\n}\n\nconst recursiveMarkUpdatesForElements = leaf => {\n  const closestUpdatesFor = leaf.parentElement.closest('updates-for')\n  if (closestUpdatesFor) {\n    closestUpdatesFor.setAttribute('performing-inner-update', '')\n    recursiveMarkUpdatesForElements(closestUpdatesFor)\n  }\n}\n\nconst recursiveUnmarkUpdatesForElements = leaf => {\n  const closestUpdatesFor = leaf.parentElement.closest('updates-for')\n  if (closestUpdatesFor) {\n    closestUpdatesFor.removeAttribute('performing-inner-update')\n    recursiveUnmarkUpdatesForElements(closestUpdatesFor)\n  }\n}\n","import CableConsumer from '../cable_consumer'\n\nimport StreamFromElement from './stream_from_element'\nimport UpdatesForElement from './updates_for_element'\n\nimport { registerInnerUpdates } from '../updatable/inner_updates_compat'\n\nconst initialize = (initializeOptions = {}) => {\n  const { consumer } = initializeOptions\n\n  registerInnerUpdates()\n\n  if (consumer) {\n    CableConsumer.setConsumer(consumer)\n  } else {\n    console.error(\n      'CableReady requires a reference to your Action Cable `consumer` for its helpers to function.\\nEnsure that you have imported the `CableReady` package as well as `consumer` from your `channels` folder, then call `CableReady.initialize({ consumer })`.'\n    )\n  }\n\n  if (!customElements.get('stream-from')) {\n    customElements.define('stream-from', StreamFromElement)\n  }\n\n  if (!customElements.get('updates-for')) {\n    customElements.define('updates-for', UpdatesForElement)\n  }\n}\n\nexport { initialize }\n","import packageInfo from '../package.json'\nimport { perform, performAsync } from './cable_ready'\nimport { initialize } from './elements'\nimport { shouldMorphCallbacks, didMorphCallbacks } from './morph_callbacks'\n\nimport * as MorphCallbacks from './morph_callbacks'\nimport * as Utils from './utils'\n\nimport OperationStore, { addOperation, addOperations } from './operation_store'\nimport StreamFromElement from './elements/stream_from_element'\nimport UpdatesForElement from './elements/updates_for_element'\nimport SubscribingElement from './elements/subscribing_element'\nimport CableConsumer from './cable_consumer'\n\nexport {\n  Utils,\n  MorphCallbacks,\n  StreamFromElement,\n  UpdatesForElement,\n  SubscribingElement\n}\n\nconst global = {\n  perform,\n  performAsync,\n  shouldMorphCallbacks,\n  didMorphCallbacks,\n  initialize,\n  addOperation,\n  addOperations,\n  version: packageInfo.version,\n  cable: CableConsumer,\n  get DOMOperations () {\n    console.warn(\n      'DEPRECATED: Please use `CableReady.operations` instead of `CableReady.DOMOperations`'\n    )\n    return OperationStore.all\n  },\n  get operations () {\n    return OperationStore.all\n  },\n  get consumer () {\n    return CableConsumer.consumer\n  }\n}\n\nwindow.CableReady = global\n\nexport default global\n"],"names":["inputTags","INPUT","TEXTAREA","SELECT","mutableTags","OPTION","textInputTypes","color","date","datetime","email","month","number","password","range","search","tel","text","textarea","time","url","week","activeElement","element","set","isTextInput","tagName","type","assignFocus","selector","nodeType","Node","ELEMENT_NODE","document","querySelector","focusElement","ActiveElement","focus","dispatch","name","detail","init","bubbles","cancelable","evt","CustomEvent","dispatchEvent","window","jQuery","trigger","xpathToElement","xpath","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","getClassNames","names","Array","flat","processElements","operation","callback","from","selectAll","forEach","kebabize","str","split","map","letter","idx","toUpperCase","toLowerCase","join","operate","cancel","delay","setTimeout","before","target","after","debounce","func","timeout","timer","args","clearTimeout","apply","this","handleErrors","response","ok","Error","statusText","async","graciouslyFetch","additionalHeaders","fetch","headers","undefined","e","console","error","shouldMorph","fromEl","toEl","shouldMorphCallbacks","includes","didMorph","el","didMorphCallbacks","verifyNotMutable","isEqualNode","verifyNotContentEditable","isContentEditable","verifyNotPermanent","permanentAttributeName","permanent","closest","ignore","value","attributes","attribute","setAttribute","append","html","focusSelector","insertAdjacentHTML","graft","parent","parentElement","appendChild","innerHtml","innerHTML","insertAdjacentHtml","position","insertAdjacentText","morph","template","createElement","String","trim","content","ordinal","children","indexOf","childrenOnly","morphdom","onBeforeElUpdated","onElUpdated","outerHtml","outerHTML","prepend","remove","replace","textContent","addCssClass","classList","add","removeAttribute","removeCssClass","setDatasetProperty","dataset","setProperty","setStyle","style","setStyles","styles","Object","entries","setValue","setMeta","meta","head","clearStorage","storage","sessionStorage","localStorage","clear","go","delta","history","pushState","state","title","redirectTo","action","Turbo","visit","Turbolinks","location","href","reload","removeStorageItem","key","removeItem","replaceState","scrollIntoView","setCookie","cookie","setFocus","setStorageItem","setItem","consoleLog","message","level","log","consoleTable","data","columns","table","notification","options","Notification","requestPermission","then","result","permission","operations","Operations","newOperations","addOperations","addOperation","all","perform","emitMissingElementWarnings","batches","batch","cableReadyOperation","OperationStore","warn","performAsync","Promise","resolve","reject","err","consumer","BACKOFF","wait","ms","getConsumerWithRetry","retry","length","setConsumer","SubscribingElement","HTMLElement","disconnectedCallback","channel","unsubscribe","createSubscription","receivedCallback","subscriptions","create","identifier","received","preview","documentElement","hasAttribute","getAttribute","StreamFromElement","CableConsumer","getConsumer","performOperations","cableReady","UpdatesForElement","constructor","super","shadowRoot","attachShadow","mode","update","bind","blocks","querySelectorAll","query","Block","uniqueUrls","Set","block","hasOwnProperty","index","process","parseInt","shouldUpdate","blockIndex","resolveTurboFrames","fragments","_","documentFragment","reloadingTurboFrames","frame","frameResponse","id","frameTemplate","ignoresInnerUpdates","hasChangesSelectedForUpdate","only","changed","some","registerInnerUpdates","addEventListener","event","recursiveMarkUpdatesForElements","recursiveUnmarkUpdatesForElements","leaf","closestUpdatesFor","initialize","initializeOptions","customElements","get","define","global","version","packageInfo","cable","DOMOperations","CableReady"],"mappings":"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"}